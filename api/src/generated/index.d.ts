// Code generated by Prisma (prisma@1.21.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  abilityScores: (where?: AbilityScoresWhereInput) => Promise<boolean>;
  character: (where?: CharacterWhereInput) => Promise<boolean>;
  class: (where?: ClassWhereInput) => Promise<boolean>;
  race: (where?: RaceWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  abilityScoreses: (
    args?: {
      where?: AbilityScoresWhereInput;
      orderBy?: AbilityScoresOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AbilityScores>;
  abilityScoresesConnection: (
    args?: {
      where?: AbilityScoresWhereInput;
      orderBy?: AbilityScoresOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AbilityScoresConnectionPromise;
  character: (where: CharacterWhereUniqueInput) => CharacterPromise;
  characters: (
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Character>;
  charactersConnection: (
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CharacterConnectionPromise;
  class: (where: ClassWhereUniqueInput) => ClassPromise;
  classes: (
    args?: {
      where?: ClassWhereInput;
      orderBy?: ClassOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Class>;
  classesConnection: (
    args?: {
      where?: ClassWhereInput;
      orderBy?: ClassOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ClassConnectionPromise;
  race: (where: RaceWhereUniqueInput) => RacePromise;
  races: (
    args?: {
      where?: RaceWhereInput;
      orderBy?: RaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Race>;
  racesConnection: (
    args?: {
      where?: RaceWhereInput;
      orderBy?: RaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RaceConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAbilityScores: (data: AbilityScoresCreateInput) => AbilityScoresPromise;
  updateManyAbilityScoreses: (
    args: {
      data: AbilityScoresUpdateManyMutationInput;
      where?: AbilityScoresWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyAbilityScoreses: (
    where?: AbilityScoresWhereInput
  ) => BatchPayloadPromise;
  createCharacter: (data: CharacterCreateInput) => CharacterPromise;
  updateCharacter: (
    args: { data: CharacterUpdateInput; where: CharacterWhereUniqueInput }
  ) => CharacterPromise;
  updateManyCharacters: (
    args: {
      data: CharacterUpdateManyMutationInput;
      where?: CharacterWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCharacter: (
    args: {
      where: CharacterWhereUniqueInput;
      create: CharacterCreateInput;
      update: CharacterUpdateInput;
    }
  ) => CharacterPromise;
  deleteCharacter: (where: CharacterWhereUniqueInput) => CharacterPromise;
  deleteManyCharacters: (where?: CharacterWhereInput) => BatchPayloadPromise;
  createClass: (data: ClassCreateInput) => ClassPromise;
  updateClass: (
    args: { data: ClassUpdateInput; where: ClassWhereUniqueInput }
  ) => ClassPromise;
  updateManyClasses: (
    args: { data: ClassUpdateManyMutationInput; where?: ClassWhereInput }
  ) => BatchPayloadPromise;
  upsertClass: (
    args: {
      where: ClassWhereUniqueInput;
      create: ClassCreateInput;
      update: ClassUpdateInput;
    }
  ) => ClassPromise;
  deleteClass: (where: ClassWhereUniqueInput) => ClassPromise;
  deleteManyClasses: (where?: ClassWhereInput) => BatchPayloadPromise;
  createRace: (data: RaceCreateInput) => RacePromise;
  updateRace: (
    args: { data: RaceUpdateInput; where: RaceWhereUniqueInput }
  ) => RacePromise;
  updateManyRaces: (
    args: { data: RaceUpdateManyMutationInput; where?: RaceWhereInput }
  ) => BatchPayloadPromise;
  upsertRace: (
    args: {
      where: RaceWhereUniqueInput;
      create: RaceCreateInput;
      update: RaceUpdateInput;
    }
  ) => RacePromise;
  deleteRace: (where: RaceWhereUniqueInput) => RacePromise;
  deleteManyRaces: (where?: RaceWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  abilityScores: (
    where?: AbilityScoresSubscriptionWhereInput
  ) => AbilityScoresSubscriptionPayloadSubscription;
  character: (
    where?: CharacterSubscriptionWhereInput
  ) => CharacterSubscriptionPayloadSubscription;
  class: (
    where?: ClassSubscriptionWhereInput
  ) => ClassSubscriptionPayloadSubscription;
  race: (
    where?: RaceSubscriptionWhereInput
  ) => RaceSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type RaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "size_ASC"
  | "size_DESC"
  | "speed_ASC"
  | "speed_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Size = "Tiny" | "Small" | "Medium" | "Large" | "Huge";

export type Language =
  | "Common"
  | "Abyssal"
  | "Draconic"
  | "Dwarven"
  | "Elven"
  | "Giant"
  | "Gnoll"
  | "Gnome"
  | "Goblin"
  | "Orc"
  | "Halfling"
  | "Sylvan"
  | "Undercommon"
  | "Terran";

export type HitDie = "D4" | "D6" | "D8" | "D10" | "D12";

export type Gender = "Male" | "Female" | "Non_Binary";

export type Alignment =
  | "Lawful_Good"
  | "Neutral_Good"
  | "Chaotic_Good"
  | "Lawful_Neutral"
  | "True_Neutral"
  | "Chaotic_Neutral"
  | "Lawful_Evil"
  | "Neutral_Evil"
  | "Chaotic_Evil";

export type AbilityScoresOrderByInput =
  | "str_ASC"
  | "str_DESC"
  | "dex_ASC"
  | "dex_DESC"
  | "con_ASC"
  | "con_DESC"
  | "int_ASC"
  | "int_DESC"
  | "wis_ASC"
  | "wis_DESC"
  | "cha_ASC"
  | "cha_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CharacterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "age_ASC"
  | "age_DESC"
  | "height_ASC"
  | "height_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "alignment_ASC"
  | "alignment_DESC"
  | "deity_ASC"
  | "deity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClassOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "hitDie_ASC"
  | "hitDie_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface RaceCreateWithoutFavoredClassInput {
  name: String;
  size: Size;
  speed: Int;
  defaultLanguages?: RaceCreatedefaultLanguagesInput;
  bonusLanguages?: RaceCreatebonusLanguagesInput;
  abilityMods?: AbilityScoresCreateOneInput;
  racialBonuses?: RaceCreateracialBonusesInput;
  characters?: CharacterCreateManyWithoutRaceInput;
}

export interface AbilityScoresWhereInput {
  str?: Int;
  str_not?: Int;
  str_in?: Int[] | Int;
  str_not_in?: Int[] | Int;
  str_lt?: Int;
  str_lte?: Int;
  str_gt?: Int;
  str_gte?: Int;
  dex?: Int;
  dex_not?: Int;
  dex_in?: Int[] | Int;
  dex_not_in?: Int[] | Int;
  dex_lt?: Int;
  dex_lte?: Int;
  dex_gt?: Int;
  dex_gte?: Int;
  con?: Int;
  con_not?: Int;
  con_in?: Int[] | Int;
  con_not_in?: Int[] | Int;
  con_lt?: Int;
  con_lte?: Int;
  con_gt?: Int;
  con_gte?: Int;
  int?: Int;
  int_not?: Int;
  int_in?: Int[] | Int;
  int_not_in?: Int[] | Int;
  int_lt?: Int;
  int_lte?: Int;
  int_gt?: Int;
  int_gte?: Int;
  wis?: Int;
  wis_not?: Int;
  wis_in?: Int[] | Int;
  wis_not_in?: Int[] | Int;
  wis_lt?: Int;
  wis_lte?: Int;
  wis_gt?: Int;
  wis_gte?: Int;
  cha?: Int;
  cha_not?: Int;
  cha_in?: Int[] | Int;
  cha_not_in?: Int[] | Int;
  cha_lt?: Int;
  cha_lte?: Int;
  cha_gt?: Int;
  cha_gte?: Int;
  AND?: AbilityScoresWhereInput[] | AbilityScoresWhereInput;
  OR?: AbilityScoresWhereInput[] | AbilityScoresWhereInput;
  NOT?: AbilityScoresWhereInput[] | AbilityScoresWhereInput;
}

export interface RaceCreatebonusLanguagesInput {
  set?: Language[] | Language;
}

export interface CharacterUpdateManyWithoutRaceInput {
  create?: CharacterCreateWithoutRaceInput[] | CharacterCreateWithoutRaceInput;
  delete?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
  connect?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
  disconnect?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
  update?:
    | CharacterUpdateWithWhereUniqueWithoutRaceInput[]
    | CharacterUpdateWithWhereUniqueWithoutRaceInput;
  upsert?:
    | CharacterUpsertWithWhereUniqueWithoutRaceInput[]
    | CharacterUpsertWithWhereUniqueWithoutRaceInput;
}

export interface AbilityScoresCreateOneInput {
  create?: AbilityScoresCreateInput;
}

export interface RaceUpdatedefaultLanguagesInput {
  set?: Language[] | Language;
}

export interface RaceCreateracialBonusesInput {
  set?: String[] | String;
}

export interface RaceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RaceWhereInput;
  AND?: RaceSubscriptionWhereInput[] | RaceSubscriptionWhereInput;
  OR?: RaceSubscriptionWhereInput[] | RaceSubscriptionWhereInput;
  NOT?: RaceSubscriptionWhereInput[] | RaceSubscriptionWhereInput;
}

export interface ClassCreateOneWithoutFavoredRacesInput {
  create?: ClassCreateWithoutFavoredRacesInput;
  connect?: ClassWhereUniqueInput;
}

export interface RaceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  size?: Size;
  size_not?: Size;
  size_in?: Size[] | Size;
  size_not_in?: Size[] | Size;
  speed?: Int;
  speed_not?: Int;
  speed_in?: Int[] | Int;
  speed_not_in?: Int[] | Int;
  speed_lt?: Int;
  speed_lte?: Int;
  speed_gt?: Int;
  speed_gte?: Int;
  abilityMods?: AbilityScoresWhereInput;
  favoredClass?: ClassWhereInput;
  characters_every?: CharacterWhereInput;
  characters_some?: CharacterWhereInput;
  characters_none?: CharacterWhereInput;
  AND?: RaceWhereInput[] | RaceWhereInput;
  OR?: RaceWhereInput[] | RaceWhereInput;
  NOT?: RaceWhereInput[] | RaceWhereInput;
}

export interface ClassCreateWithoutFavoredRacesInput {
  name: String;
  hitDie: HitDie;
  characters?: CharacterCreateManyWithoutClassInput;
}

export interface CharacterWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  race?: RaceWhereInput;
  gender?: Gender;
  gender_not?: Gender;
  gender_in?: Gender[] | Gender;
  gender_not_in?: Gender[] | Gender;
  age?: Int;
  age_not?: Int;
  age_in?: Int[] | Int;
  age_not_in?: Int[] | Int;
  age_lt?: Int;
  age_lte?: Int;
  age_gt?: Int;
  age_gte?: Int;
  height?: Int;
  height_not?: Int;
  height_in?: Int[] | Int;
  height_not_in?: Int[] | Int;
  height_lt?: Int;
  height_lte?: Int;
  height_gt?: Int;
  height_gte?: Int;
  weight?: Int;
  weight_not?: Int;
  weight_in?: Int[] | Int;
  weight_not_in?: Int[] | Int;
  weight_lt?: Int;
  weight_lte?: Int;
  weight_gt?: Int;
  weight_gte?: Int;
  alignment?: Alignment;
  alignment_not?: Alignment;
  alignment_in?: Alignment[] | Alignment;
  alignment_not_in?: Alignment[] | Alignment;
  class?: ClassWhereInput;
  deity?: String;
  deity_not?: String;
  deity_in?: String[] | String;
  deity_not_in?: String[] | String;
  deity_lt?: String;
  deity_lte?: String;
  deity_gt?: String;
  deity_gte?: String;
  deity_contains?: String;
  deity_not_contains?: String;
  deity_starts_with?: String;
  deity_not_starts_with?: String;
  deity_ends_with?: String;
  deity_not_ends_with?: String;
  owner?: UserWhereInput;
  AND?: CharacterWhereInput[] | CharacterWhereInput;
  OR?: CharacterWhereInput[] | CharacterWhereInput;
  NOT?: CharacterWhereInput[] | CharacterWhereInput;
}

export interface CharacterCreateManyWithoutClassInput {
  create?:
    | CharacterCreateWithoutClassInput[]
    | CharacterCreateWithoutClassInput;
  connect?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
}

export interface CharacterSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CharacterWhereInput;
  AND?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
  OR?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
  NOT?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
}

export interface CharacterCreateWithoutClassInput {
  name: String;
  race: RaceCreateOneWithoutCharactersInput;
  gender: Gender;
  age: Int;
  height: Int;
  weight: Int;
  alignment: Alignment;
  deity?: String;
  owner: UserCreateOneWithoutCharactersInput;
}

export interface AbilityScoresSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AbilityScoresWhereInput;
  AND?:
    | AbilityScoresSubscriptionWhereInput[]
    | AbilityScoresSubscriptionWhereInput;
  OR?:
    | AbilityScoresSubscriptionWhereInput[]
    | AbilityScoresSubscriptionWhereInput;
  NOT?:
    | AbilityScoresSubscriptionWhereInput[]
    | AbilityScoresSubscriptionWhereInput;
}

export interface UserCreateOneWithoutCharactersInput {
  create?: UserCreateWithoutCharactersInput;
  connect?: UserWhereUniqueInput;
}

export interface CharacterUpsertWithWhereUniqueWithoutOwnerInput {
  where: CharacterWhereUniqueInput;
  update: CharacterUpdateWithoutOwnerDataInput;
  create: CharacterCreateWithoutOwnerInput;
}

export interface UserCreateWithoutCharactersInput {
  name: String;
  email: String;
  password: String;
}

export interface CharacterUpdateWithWhereUniqueWithoutOwnerInput {
  where: CharacterWhereUniqueInput;
  data: CharacterUpdateWithoutOwnerDataInput;
}

export interface ClassCreateOneWithoutCharactersInput {
  create?: ClassCreateWithoutCharactersInput;
  connect?: ClassWhereUniqueInput;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  characters?: CharacterUpdateManyWithoutOwnerInput;
}

export interface ClassCreateWithoutCharactersInput {
  name: String;
  hitDie: HitDie;
  favoredRaces?: RaceCreateManyWithoutFavoredClassInput;
}

export interface CharacterCreateWithoutOwnerInput {
  name: String;
  race: RaceCreateOneWithoutCharactersInput;
  gender: Gender;
  age: Int;
  height: Int;
  weight: Int;
  alignment: Alignment;
  class: ClassCreateOneWithoutCharactersInput;
  deity?: String;
}

export interface RaceCreateManyWithoutFavoredClassInput {
  create?:
    | RaceCreateWithoutFavoredClassInput[]
    | RaceCreateWithoutFavoredClassInput;
  connect?: RaceWhereUniqueInput[] | RaceWhereUniqueInput;
}

export interface UserCreateInput {
  name: String;
  email: String;
  password: String;
  characters?: CharacterCreateManyWithoutOwnerInput;
}

export interface CharacterUpdateWithoutRaceDataInput {
  name?: String;
  gender?: Gender;
  age?: Int;
  height?: Int;
  weight?: Int;
  alignment?: Alignment;
  class?: ClassUpdateOneRequiredWithoutCharactersInput;
  deity?: String;
  owner?: UserUpdateOneRequiredWithoutCharactersInput;
}

export type RaceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface CharacterCreateManyWithoutRaceInput {
  create?: CharacterCreateWithoutRaceInput[] | CharacterCreateWithoutRaceInput;
  connect?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
}

export interface RaceCreateInput {
  name: String;
  size: Size;
  speed: Int;
  defaultLanguages?: RaceCreatedefaultLanguagesInput;
  bonusLanguages?: RaceCreatebonusLanguagesInput;
  abilityMods?: AbilityScoresCreateOneInput;
  racialBonuses?: RaceCreateracialBonusesInput;
  favoredClass?: ClassCreateOneWithoutFavoredRacesInput;
  characters?: CharacterCreateManyWithoutRaceInput;
}

export interface CharacterCreateWithoutRaceInput {
  name: String;
  gender: Gender;
  age: Int;
  height: Int;
  weight: Int;
  alignment: Alignment;
  class: ClassCreateOneWithoutCharactersInput;
  deity?: String;
  owner: UserCreateOneWithoutCharactersInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface CharacterUpdateInput {
  name?: String;
  race?: RaceUpdateOneRequiredWithoutCharactersInput;
  gender?: Gender;
  age?: Int;
  height?: Int;
  weight?: Int;
  alignment?: Alignment;
  class?: ClassUpdateOneRequiredWithoutCharactersInput;
  deity?: String;
  owner?: UserUpdateOneRequiredWithoutCharactersInput;
}

export interface ClassCreateInput {
  name: String;
  hitDie: HitDie;
  favoredRaces?: RaceCreateManyWithoutFavoredClassInput;
  characters?: CharacterCreateManyWithoutClassInput;
}

export interface RaceUpdateOneRequiredWithoutCharactersInput {
  create?: RaceCreateWithoutCharactersInput;
  update?: RaceUpdateWithoutCharactersDataInput;
  upsert?: RaceUpsertWithoutCharactersInput;
  connect?: RaceWhereUniqueInput;
}

export interface ClassUpsertWithoutCharactersInput {
  update: ClassUpdateWithoutCharactersDataInput;
  create: ClassCreateWithoutCharactersInput;
}

export interface RaceUpdateWithoutCharactersDataInput {
  name?: String;
  size?: Size;
  speed?: Int;
  defaultLanguages?: RaceUpdatedefaultLanguagesInput;
  bonusLanguages?: RaceUpdatebonusLanguagesInput;
  abilityMods?: AbilityScoresUpdateOneInput;
  racialBonuses?: RaceUpdateracialBonusesInput;
  favoredClass?: ClassUpdateOneWithoutFavoredRacesInput;
}

export interface AbilityScoresCreateInput {
  str?: Int;
  dex?: Int;
  con?: Int;
  int?: Int;
  wis?: Int;
  cha?: Int;
}

export interface CharacterUpdateWithWhereUniqueWithoutRaceInput {
  where: CharacterWhereUniqueInput;
  data: CharacterUpdateWithoutRaceDataInput;
}

export interface RaceUpsertWithWhereUniqueWithoutFavoredClassInput {
  where: RaceWhereUniqueInput;
  update: RaceUpdateWithoutFavoredClassDataInput;
  create: RaceCreateWithoutFavoredClassInput;
}

export interface RaceUpdatebonusLanguagesInput {
  set?: Language[] | Language;
}

export interface CharacterCreateInput {
  name: String;
  race: RaceCreateOneWithoutCharactersInput;
  gender: Gender;
  age: Int;
  height: Int;
  weight: Int;
  alignment: Alignment;
  class: ClassCreateOneWithoutCharactersInput;
  deity?: String;
  owner: UserCreateOneWithoutCharactersInput;
}

export interface AbilityScoresUpdateOneInput {
  create?: AbilityScoresCreateInput;
  update?: AbilityScoresUpdateDataInput;
  upsert?: AbilityScoresUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface RaceCreateWithoutCharactersInput {
  name: String;
  size: Size;
  speed: Int;
  defaultLanguages?: RaceCreatedefaultLanguagesInput;
  bonusLanguages?: RaceCreatebonusLanguagesInput;
  abilityMods?: AbilityScoresCreateOneInput;
  racialBonuses?: RaceCreateracialBonusesInput;
  favoredClass?: ClassCreateOneWithoutFavoredRacesInput;
}

export interface AbilityScoresUpdateDataInput {
  str?: Int;
  dex?: Int;
  con?: Int;
  int?: Int;
  wis?: Int;
  cha?: Int;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface AbilityScoresUpsertNestedInput {
  update: AbilityScoresUpdateDataInput;
  create: AbilityScoresCreateInput;
}

export interface ClassWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  hitDie?: HitDie;
  hitDie_not?: HitDie;
  hitDie_in?: HitDie[] | HitDie;
  hitDie_not_in?: HitDie[] | HitDie;
  favoredRaces_every?: RaceWhereInput;
  favoredRaces_some?: RaceWhereInput;
  favoredRaces_none?: RaceWhereInput;
  characters_every?: CharacterWhereInput;
  characters_some?: CharacterWhereInput;
  characters_none?: CharacterWhereInput;
  AND?: ClassWhereInput[] | ClassWhereInput;
  OR?: ClassWhereInput[] | ClassWhereInput;
  NOT?: ClassWhereInput[] | ClassWhereInput;
}

export interface RaceUpdateracialBonusesInput {
  set?: String[] | String;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  characters_every?: CharacterWhereInput;
  characters_some?: CharacterWhereInput;
  characters_none?: CharacterWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ClassUpdateOneWithoutFavoredRacesInput {
  create?: ClassCreateWithoutFavoredRacesInput;
  update?: ClassUpdateWithoutFavoredRacesDataInput;
  upsert?: ClassUpsertWithoutFavoredRacesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ClassWhereUniqueInput;
}

export interface CharacterUpdateWithoutOwnerDataInput {
  name?: String;
  race?: RaceUpdateOneRequiredWithoutCharactersInput;
  gender?: Gender;
  age?: Int;
  height?: Int;
  weight?: Int;
  alignment?: Alignment;
  class?: ClassUpdateOneRequiredWithoutCharactersInput;
  deity?: String;
}

export interface ClassUpdateWithoutFavoredRacesDataInput {
  name?: String;
  hitDie?: HitDie;
  characters?: CharacterUpdateManyWithoutClassInput;
}

export type ClassWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface CharacterUpdateManyWithoutClassInput {
  create?:
    | CharacterCreateWithoutClassInput[]
    | CharacterCreateWithoutClassInput;
  delete?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
  connect?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
  disconnect?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
  update?:
    | CharacterUpdateWithWhereUniqueWithoutClassInput[]
    | CharacterUpdateWithWhereUniqueWithoutClassInput;
  upsert?:
    | CharacterUpsertWithWhereUniqueWithoutClassInput[]
    | CharacterUpsertWithWhereUniqueWithoutClassInput;
}

export interface RaceUpdateManyMutationInput {
  name?: String;
  size?: Size;
  speed?: Int;
  defaultLanguages?: RaceUpdatedefaultLanguagesInput;
  bonusLanguages?: RaceUpdatebonusLanguagesInput;
  racialBonuses?: RaceUpdateracialBonusesInput;
}

export interface CharacterUpdateWithWhereUniqueWithoutClassInput {
  where: CharacterWhereUniqueInput;
  data: CharacterUpdateWithoutClassDataInput;
}

export interface ClassUpdateManyMutationInput {
  name?: String;
  hitDie?: HitDie;
}

export interface CharacterUpdateWithoutClassDataInput {
  name?: String;
  race?: RaceUpdateOneRequiredWithoutCharactersInput;
  gender?: Gender;
  age?: Int;
  height?: Int;
  weight?: Int;
  alignment?: Alignment;
  deity?: String;
  owner?: UserUpdateOneRequiredWithoutCharactersInput;
}

export interface CharacterUpdateManyMutationInput {
  name?: String;
  gender?: Gender;
  age?: Int;
  height?: Int;
  weight?: Int;
  alignment?: Alignment;
  deity?: String;
}

export interface UserUpdateOneRequiredWithoutCharactersInput {
  create?: UserCreateWithoutCharactersInput;
  update?: UserUpdateWithoutCharactersDataInput;
  upsert?: UserUpsertWithoutCharactersInput;
  connect?: UserWhereUniqueInput;
}

export interface AbilityScoresUpdateManyMutationInput {
  str?: Int;
  dex?: Int;
  con?: Int;
  int?: Int;
  wis?: Int;
  cha?: Int;
}

export interface UserUpdateWithoutCharactersDataInput {
  name?: String;
  email?: String;
  password?: String;
}

export interface RaceCreateOneWithoutCharactersInput {
  create?: RaceCreateWithoutCharactersInput;
  connect?: RaceWhereUniqueInput;
}

export interface UserUpsertWithoutCharactersInput {
  update: UserUpdateWithoutCharactersDataInput;
  create: UserCreateWithoutCharactersInput;
}

export type CharacterWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CharacterUpsertWithWhereUniqueWithoutClassInput {
  where: CharacterWhereUniqueInput;
  update: CharacterUpdateWithoutClassDataInput;
  create: CharacterCreateWithoutClassInput;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
}

export interface ClassUpsertWithoutFavoredRacesInput {
  update: ClassUpdateWithoutFavoredRacesDataInput;
  create: ClassCreateWithoutFavoredRacesInput;
}

export interface CharacterCreateManyWithoutOwnerInput {
  create?:
    | CharacterCreateWithoutOwnerInput[]
    | CharacterCreateWithoutOwnerInput;
  connect?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
}

export interface RaceUpsertWithoutCharactersInput {
  update: RaceUpdateWithoutCharactersDataInput;
  create: RaceCreateWithoutCharactersInput;
}

export interface ClassUpdateInput {
  name?: String;
  hitDie?: HitDie;
  favoredRaces?: RaceUpdateManyWithoutFavoredClassInput;
  characters?: CharacterUpdateManyWithoutClassInput;
}

export interface ClassUpdateOneRequiredWithoutCharactersInput {
  create?: ClassCreateWithoutCharactersInput;
  update?: ClassUpdateWithoutCharactersDataInput;
  upsert?: ClassUpsertWithoutCharactersInput;
  connect?: ClassWhereUniqueInput;
}

export interface CharacterUpsertWithWhereUniqueWithoutRaceInput {
  where: CharacterWhereUniqueInput;
  update: CharacterUpdateWithoutRaceDataInput;
  create: CharacterCreateWithoutRaceInput;
}

export interface ClassSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ClassWhereInput;
  AND?: ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput;
  OR?: ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput;
  NOT?: ClassSubscriptionWhereInput[] | ClassSubscriptionWhereInput;
}

export interface RaceUpdateWithoutFavoredClassDataInput {
  name?: String;
  size?: Size;
  speed?: Int;
  defaultLanguages?: RaceUpdatedefaultLanguagesInput;
  bonusLanguages?: RaceUpdatebonusLanguagesInput;
  abilityMods?: AbilityScoresUpdateOneInput;
  racialBonuses?: RaceUpdateracialBonusesInput;
  characters?: CharacterUpdateManyWithoutRaceInput;
}

export interface RaceUpdateWithWhereUniqueWithoutFavoredClassInput {
  where: RaceWhereUniqueInput;
  data: RaceUpdateWithoutFavoredClassDataInput;
}

export interface RaceUpdateManyWithoutFavoredClassInput {
  create?:
    | RaceCreateWithoutFavoredClassInput[]
    | RaceCreateWithoutFavoredClassInput;
  delete?: RaceWhereUniqueInput[] | RaceWhereUniqueInput;
  connect?: RaceWhereUniqueInput[] | RaceWhereUniqueInput;
  disconnect?: RaceWhereUniqueInput[] | RaceWhereUniqueInput;
  update?:
    | RaceUpdateWithWhereUniqueWithoutFavoredClassInput[]
    | RaceUpdateWithWhereUniqueWithoutFavoredClassInput;
  upsert?:
    | RaceUpsertWithWhereUniqueWithoutFavoredClassInput[]
    | RaceUpsertWithWhereUniqueWithoutFavoredClassInput;
}

export interface ClassUpdateWithoutCharactersDataInput {
  name?: String;
  hitDie?: HitDie;
  favoredRaces?: RaceUpdateManyWithoutFavoredClassInput;
}

export interface CharacterUpdateManyWithoutOwnerInput {
  create?:
    | CharacterCreateWithoutOwnerInput[]
    | CharacterCreateWithoutOwnerInput;
  delete?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
  connect?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
  disconnect?: CharacterWhereUniqueInput[] | CharacterWhereUniqueInput;
  update?:
    | CharacterUpdateWithWhereUniqueWithoutOwnerInput[]
    | CharacterUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | CharacterUpsertWithWhereUniqueWithoutOwnerInput[]
    | CharacterUpsertWithWhereUniqueWithoutOwnerInput;
}

export interface RaceCreatedefaultLanguagesInput {
  set?: Language[] | Language;
}

export interface RaceUpdateInput {
  name?: String;
  size?: Size;
  speed?: Int;
  defaultLanguages?: RaceUpdatedefaultLanguagesInput;
  bonusLanguages?: RaceUpdatebonusLanguagesInput;
  abilityMods?: AbilityScoresUpdateOneInput;
  racialBonuses?: RaceUpdateracialBonusesInput;
  favoredClass?: ClassUpdateOneWithoutFavoredRacesInput;
  characters?: CharacterUpdateManyWithoutRaceInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  characters: <T = FragmentableArray<Character>>(
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  characters: <T = Promise<AsyncIterator<CharacterSubscription>>>(
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Race {
  id: ID_Output;
  name: String;
  size: Size;
  speed: Int;
  defaultLanguages: Language[];
  bonusLanguages: Language[];
  racialBonuses: String[];
}

export interface RacePromise extends Promise<Race>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<Size>;
  speed: () => Promise<Int>;
  defaultLanguages: () => Promise<Language[]>;
  bonusLanguages: () => Promise<Language[]>;
  abilityMods: <T = AbilityScoresPromise>() => T;
  racialBonuses: () => Promise<String[]>;
  favoredClass: <T = ClassPromise>() => T;
  characters: <T = FragmentableArray<Character>>(
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RaceSubscription
  extends Promise<AsyncIterator<Race>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Size>>;
  speed: () => Promise<AsyncIterator<Int>>;
  defaultLanguages: () => Promise<AsyncIterator<Language[]>>;
  bonusLanguages: () => Promise<AsyncIterator<Language[]>>;
  abilityMods: <T = AbilityScoresSubscription>() => T;
  racialBonuses: () => Promise<AsyncIterator<String[]>>;
  favoredClass: <T = ClassSubscription>() => T;
  characters: <T = Promise<AsyncIterator<CharacterSubscription>>>(
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Character {
  id: ID_Output;
  name: String;
  gender: Gender;
  age: Int;
  height: Int;
  weight: Int;
  alignment: Alignment;
  deity?: String;
}

export interface CharacterPromise extends Promise<Character>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  race: <T = RacePromise>() => T;
  gender: () => Promise<Gender>;
  age: () => Promise<Int>;
  height: () => Promise<Int>;
  weight: () => Promise<Int>;
  alignment: () => Promise<Alignment>;
  class: <T = ClassPromise>() => T;
  deity: () => Promise<String>;
  owner: <T = UserPromise>() => T;
}

export interface CharacterSubscription
  extends Promise<AsyncIterator<Character>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  race: <T = RaceSubscription>() => T;
  gender: () => Promise<AsyncIterator<Gender>>;
  age: () => Promise<AsyncIterator<Int>>;
  height: () => Promise<AsyncIterator<Int>>;
  weight: () => Promise<AsyncIterator<Int>>;
  alignment: () => Promise<AsyncIterator<Alignment>>;
  class: <T = ClassSubscription>() => T;
  deity: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Class {
  id: ID_Output;
  name: String;
  hitDie: HitDie;
}

export interface ClassPromise extends Promise<Class>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  hitDie: () => Promise<HitDie>;
  favoredRaces: <T = FragmentableArray<Race>>(
    args?: {
      where?: RaceWhereInput;
      orderBy?: RaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  characters: <T = FragmentableArray<Character>>(
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ClassSubscription
  extends Promise<AsyncIterator<Class>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  hitDie: () => Promise<AsyncIterator<HitDie>>;
  favoredRaces: <T = Promise<AsyncIterator<RaceSubscription>>>(
    args?: {
      where?: RaceWhereInput;
      orderBy?: RaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  characters: <T = Promise<AsyncIterator<CharacterSubscription>>>(
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AbilityScores {
  str?: Int;
  dex?: Int;
  con?: Int;
  int?: Int;
  wis?: Int;
  cha?: Int;
}

export interface AbilityScoresPromise
  extends Promise<AbilityScores>,
    Fragmentable {
  str: () => Promise<Int>;
  dex: () => Promise<Int>;
  con: () => Promise<Int>;
  int: () => Promise<Int>;
  wis: () => Promise<Int>;
  cha: () => Promise<Int>;
}

export interface AbilityScoresSubscription
  extends Promise<AsyncIterator<AbilityScores>>,
    Fragmentable {
  str: () => Promise<AsyncIterator<Int>>;
  dex: () => Promise<AsyncIterator<Int>>;
  con: () => Promise<AsyncIterator<Int>>;
  int: () => Promise<AsyncIterator<Int>>;
  wis: () => Promise<AsyncIterator<Int>>;
  cha: () => Promise<AsyncIterator<Int>>;
}

export interface RacePreviousValues {
  id: ID_Output;
  name: String;
  size: Size;
  speed: Int;
  defaultLanguages: Language[];
  bonusLanguages: Language[];
  racialBonuses: String[];
}

export interface RacePreviousValuesPromise
  extends Promise<RacePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  size: () => Promise<Size>;
  speed: () => Promise<Int>;
  defaultLanguages: () => Promise<Language[]>;
  bonusLanguages: () => Promise<Language[]>;
  racialBonuses: () => Promise<String[]>;
}

export interface RacePreviousValuesSubscription
  extends Promise<AsyncIterator<RacePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Size>>;
  speed: () => Promise<AsyncIterator<Int>>;
  defaultLanguages: () => Promise<AsyncIterator<Language[]>>;
  bonusLanguages: () => Promise<AsyncIterator<Language[]>>;
  racialBonuses: () => Promise<AsyncIterator<String[]>>;
}

export interface RaceEdge {
  cursor: String;
}

export interface RaceEdgePromise extends Promise<RaceEdge>, Fragmentable {
  node: <T = RacePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RaceEdgeSubscription
  extends Promise<AsyncIterator<RaceEdge>>,
    Fragmentable {
  node: <T = RaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RaceSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RaceSubscriptionPayloadPromise
  extends Promise<RaceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RacePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RacePreviousValuesPromise>() => T;
}

export interface RaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RaceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RacePreviousValuesSubscription>() => T;
}

export interface AggregateClass {
  count: Int;
}

export interface AggregateClassPromise
  extends Promise<AggregateClass>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassSubscription
  extends Promise<AsyncIterator<AggregateClass>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AbilityScoresSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AbilityScoresSubscriptionPayloadPromise
  extends Promise<AbilityScoresSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AbilityScoresPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AbilityScoresPreviousValuesPromise>() => T;
}

export interface AbilityScoresSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AbilityScoresSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AbilityScoresSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AbilityScoresPreviousValuesSubscription>() => T;
}

export interface ClassConnection {}

export interface ClassConnectionPromise
  extends Promise<ClassConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassEdge>>() => T;
  aggregate: <T = AggregateClassPromise>() => T;
}

export interface ClassConnectionSubscription
  extends Promise<AsyncIterator<ClassConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassSubscription>() => T;
}

export interface AbilityScoresPreviousValues {
  str?: Int;
  dex?: Int;
  con?: Int;
  int?: Int;
  wis?: Int;
  cha?: Int;
}

export interface AbilityScoresPreviousValuesPromise
  extends Promise<AbilityScoresPreviousValues>,
    Fragmentable {
  str: () => Promise<Int>;
  dex: () => Promise<Int>;
  con: () => Promise<Int>;
  int: () => Promise<Int>;
  wis: () => Promise<Int>;
  cha: () => Promise<Int>;
}

export interface AbilityScoresPreviousValuesSubscription
  extends Promise<AsyncIterator<AbilityScoresPreviousValues>>,
    Fragmentable {
  str: () => Promise<AsyncIterator<Int>>;
  dex: () => Promise<AsyncIterator<Int>>;
  con: () => Promise<AsyncIterator<Int>>;
  int: () => Promise<AsyncIterator<Int>>;
  wis: () => Promise<AsyncIterator<Int>>;
  cha: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCharacter {
  count: Int;
}

export interface AggregateCharacterPromise
  extends Promise<AggregateCharacter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharacterSubscription
  extends Promise<AsyncIterator<AggregateCharacter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AbilityScoresEdge {
  cursor: String;
}

export interface AbilityScoresEdgePromise
  extends Promise<AbilityScoresEdge>,
    Fragmentable {
  node: <T = AbilityScoresPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AbilityScoresEdgeSubscription
  extends Promise<AsyncIterator<AbilityScoresEdge>>,
    Fragmentable {
  node: <T = AbilityScoresSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharacterConnection {}

export interface CharacterConnectionPromise
  extends Promise<CharacterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharacterEdge>>() => T;
  aggregate: <T = AggregateCharacterPromise>() => T;
}

export interface CharacterConnectionSubscription
  extends Promise<AsyncIterator<CharacterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharacterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharacterSubscription>() => T;
}

export interface CharacterSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CharacterSubscriptionPayloadPromise
  extends Promise<CharacterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharacterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharacterPreviousValuesPromise>() => T;
}

export interface CharacterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharacterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharacterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharacterPreviousValuesSubscription>() => T;
}

export interface AggregateRace {
  count: Int;
}

export interface AggregateRacePromise
  extends Promise<AggregateRace>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRaceSubscription
  extends Promise<AsyncIterator<AggregateRace>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassEdge {
  cursor: String;
}

export interface ClassEdgePromise extends Promise<ClassEdge>, Fragmentable {
  node: <T = ClassPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassEdgeSubscription
  extends Promise<AsyncIterator<ClassEdge>>,
    Fragmentable {
  node: <T = ClassSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ClassPreviousValues {
  id: ID_Output;
  name: String;
  hitDie: HitDie;
}

export interface ClassPreviousValuesPromise
  extends Promise<ClassPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  hitDie: () => Promise<HitDie>;
}

export interface ClassPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  hitDie: () => Promise<AsyncIterator<HitDie>>;
}

export interface ClassSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ClassSubscriptionPayloadPromise
  extends Promise<ClassSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassPreviousValuesPromise>() => T;
}

export interface ClassSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassPreviousValuesSubscription>() => T;
}

export interface AggregateAbilityScores {
  count: Int;
}

export interface AggregateAbilityScoresPromise
  extends Promise<AggregateAbilityScores>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAbilityScoresSubscription
  extends Promise<AsyncIterator<AggregateAbilityScores>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CharacterPreviousValues {
  id: ID_Output;
  name: String;
  gender: Gender;
  age: Int;
  height: Int;
  weight: Int;
  alignment: Alignment;
  deity?: String;
}

export interface CharacterPreviousValuesPromise
  extends Promise<CharacterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  gender: () => Promise<Gender>;
  age: () => Promise<Int>;
  height: () => Promise<Int>;
  weight: () => Promise<Int>;
  alignment: () => Promise<Alignment>;
  deity: () => Promise<String>;
}

export interface CharacterPreviousValuesSubscription
  extends Promise<AsyncIterator<CharacterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  age: () => Promise<AsyncIterator<Int>>;
  height: () => Promise<AsyncIterator<Int>>;
  weight: () => Promise<AsyncIterator<Int>>;
  alignment: () => Promise<AsyncIterator<Alignment>>;
  deity: () => Promise<AsyncIterator<String>>;
}

export interface AbilityScoresConnection {}

export interface AbilityScoresConnectionPromise
  extends Promise<AbilityScoresConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AbilityScoresEdge>>() => T;
  aggregate: <T = AggregateAbilityScoresPromise>() => T;
}

export interface AbilityScoresConnectionSubscription
  extends Promise<AsyncIterator<AbilityScoresConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AbilityScoresEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAbilityScoresSubscription>() => T;
}

export interface RaceConnection {}

export interface RaceConnectionPromise
  extends Promise<RaceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RaceEdge>>() => T;
  aggregate: <T = AggregateRacePromise>() => T;
}

export interface RaceConnectionSubscription
  extends Promise<AsyncIterator<RaceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRaceSubscription>() => T;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface CharacterEdge {
  cursor: String;
}

export interface CharacterEdgePromise
  extends Promise<CharacterEdge>,
    Fragmentable {
  node: <T = CharacterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharacterEdgeSubscription
  extends Promise<AsyncIterator<CharacterEdge>>,
    Fragmentable {
  node: <T = CharacterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "AbilityScores",
    embedded: false
  },
  {
    name: "Alignment",
    embedded: false
  },
  {
    name: "Character",
    embedded: false
  },
  {
    name: "Class",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "HitDie",
    embedded: false
  },
  {
    name: "Language",
    embedded: false
  },
  {
    name: "Race",
    embedded: false
  },
  {
    name: "Size",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
